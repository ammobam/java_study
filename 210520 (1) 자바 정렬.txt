**Class

1. Method
Function (함수) : 독립적으로 메모리(Stack, 자료구조)를 할당받아서 실행할 수 있는 단위. 코드의 모임.
- 함수를 독립적으로 작성할 수 있는 언어와 있는 언어가 구분됨.
-- 자바는 함수를 독립적으로 생성할 수 없음
-- 자바는 모든 함수가 클래스 안에 만들어져야 함
-- 자바는 완전한 객체 지향 언어라고 부름

함수를 만드는 이유? 코드를 쪼개기 위해.
    (1) 유지보수의 편의성을 위해 코드를 블럭화 하는 것. 코드의 중복 방지.
	-- 상속, 클래스 이용, 함수 작성 등으로 코드의 중복을 제거함
    (2) 메모리를 효율적으로 사용하기 위함
	-- Java는 배열을 heap에 만듬. 배열을 크게 만들 수 있음.
	-- C는 배열을 Stack에 만듬. 1mb이상 만들면 OverStack 경고.
	-- 적절하게 코드 쪼개는 것은 매우 중요함

1) 함수의 선언 구조
	[접근지정자] + [함수의특성] + return타입 + 이름 + ( 매개변수 나열 ) { 
		함수의내용 
	}

2) 접근지정자 (Access Modifier)
privite : 클래스 내에서만 사용 가능
	-- 파이썬에서 __iter__
default : 동일한 패키지 내에서 public, 다른 패키지에서는 private. 접근지정자를 생략하는 것으로 package라고도 함.
	-- UML에서는 package라고 함. 그러니 package라는 말을 쓰자.
protected : 클래스 내부에서 사용. 상속받은 클래스 안에서 상속 가능.
public : 클래스 내부에서 사용. 인스턴스 사용 가능.

프로퍼티(클래스 안에 만든 변수)와 메소드에 지정 가능함
-- setter/getter에서 set과 get 이후에 나오는 단어가 property
-- 접근지정자는 프로퍼티와 메소드에 접근 권한을 설정함
-- 사용자가 알 필요 없는 부분은 접근 자체를 못하게 해야함
-- 프로퍼티는 특별한 경우를 제외하고 privite나 protected로 설정함. 외부에서 호출할 메소드만 public으로 설정함.

메소드 
- 동기화의 최소 단위
-- 파이썬 : 스레드, 포레트


3) 함수의 특성 - 생략 가능한 부분
static : 클래스로 호출 가능. this가 없음
syncronized : 동기화 메소드. 동시에 호출하면 하나의 작업이 끝날 때까지 다른 메소드는 대기하도록 만들어줌
abstract : 추상 메소드. 내용이 없는 메소드로 상속 받은 클래스에서 반드시 재정의 (Override) 해야함.
final : 종단 메소드. Overriding(재정의) 할 수 없는 메소드.
native : 운영체제의 기능을 직접 호출해서 사용하는 메소드. C언어로 작성.
	- 그래픽 가속(Open GL, Direct X)에서 많이 사용함.


4) 리턴 타입
함수는 호출하면 현재 스택의 참조를 기억하고 다른 스택을 할당받아서 수행하고, 작업이 끝나면 자신을 호출한 곳으로 돌아감. 이를 return이라 함.
return할 때 하나의 데이터를 가지고 갈 수 있음.
가지고 가는 데이터의 자료형을 리턴타입이라고 하며 생략이 불가능함.
리턴할 때 데이터를 가지고 가지 않는 경우는 void라고 기재해야 함.
	- void일 때 return 생략 가능.
	- 단, return 뒤에 문장 없어야 함
	-- python에서 자주 하는 실수
	   print(리턴타입이 아닌 함수를 호출) : None


5) 이름
메소드의 이름으로 식별자 규칙을 지키기.
이름만 보면 어떤 기능을 하는지 알 수 있도록 작성해야 함.
-- 데이터 분석 시 한 눈에 어떤 작업을 수행한 데이터인지 알아봐야함.


6) 매개변수
- argument : 외부에서 바라볼 때 이름
- parameter : 내부에서 바라볼 때 이름
- 메소드를 호출할 때 메소드에게 넘겨주는 데이터.
- 매개변수는 생략 가능함
- 매개변수는 함수 내 지역변수가 됨


7) 내용을 작성할 때 return type이 있는 경우는 반드시 return type과 일치하는 데이터를 만들어서 return해줘야 함.
return다음에 어떤 문장도 오면 안 됨.


8) call by value와 call by reference
	// Main.java , SampleClass.java 파일 참고

call by value
	- 매개변수가 기본 scalar 자료형으로 만들어짐.
	- 메소드 내에서 외부에서 만든 데이터를 수정할 수 없음
call by reference
	- 매개변수가 vector 자료형으로 만들어짐.
	- 메소드 내에서 외부에서 만든 데이터를 수정할 수 있음
	-- ! 그러나 메모리 이슈 때문에 수정하는 것을 권장하지 않음
	-- 외부 데이터를 메소드 내부에서 수정하게 되면 어떤 알고리즘을 적용해서 어떻게 수정했는지 알아보기 어려움.
	-- R 에서 =, <-를 많이 쓰는 이유. 함수 단독으로 쓰는 경우가 없음

	Heloo OOP
	n:31	// callByValue로 부른 값
	x::30	//  int x 값
	ar[0]31	// callByRef로 부른 값
	ar[0]::31	// 원래 배열 값


9) 접근자 메소드 (getter, setter)
클래스 내부에 만든 변수에 접근하기 위한 메소드
getter : 변수 값을 리턴하는 메소드
setter : 변수의 값을 매개변수로 변경하는 메소드
- 객체 지향 언어에서 클래스 안에 만든 변수들은 접근지정자를 private로 설정해서 외부에서 접근할 수 없도록 하고 getter와 setter를 이용해서 접근하도록 함

-- 최근 등장한 kotlin, swift 언어는 클래스 내부에 변수를 만들면 자동으로 getter, setter를 생성해줌.
-- Java도 lombok 라이브러리를 이용해서 어노테이션으로 자동 생성함 (Spring등 프레임워크 사용 할 때 많이 사용)
-- 대다수 IDE는 자동으로 만들어줌

getter 생성
	get 변수명
	-- 변수명의 첫글자는 대문자
	-- 변수의 자료형이 boolean이면 get 대신 is 사용
		-- is로 시작하는 함수의 리턴값은 T/F임
	-- 변수의 내용을 리턴함
	-- 변수가 없는데 get 메소드를 만드는 경우 연산 프로퍼티라고 함
		-- 자주 사용하는 계산식, 계산값은 저장해야 속도 빠름
		-- 이 경우 변수 없이 get만 쓰기도 함
		-- 중복은 최소화하는게 좋지만, 특별한 경우 필요함
			de-nomalization, 고장난 경우 ,noSQL...
	- 변수 없이 get만 쓰는 경우 / .,,,,,,경우....,?

setter 생성
	set 변수명
	-- 매개변수를 변수의 자료형 1개로 만듬
	-- 내용은 매개변수의 값을 변수에 대입함
	-- 변수에 대입하기 '전'에 유효성 검사를 수행하거나 특정 범위 내의 값만을 갖기도 함
		-- 설문지 작성시 성별란에 결측치 없도록 전 작업 등등...
		-- 이상치, 결측치를 사전에 줄이는 것이 중요함

- 변수가 배열이라면 하나의 데이터, 인덱스를 받아서 부분적으로 수정하거나 
- 인덱스만 받아서 부분적으로 리턴하는 메소드로 만들어주는 것이 좋음
	-- 받은 데이터는 튜플보단 부분만 떼서 사용할 수 있는 객체, 리스트로 저장하는 것이 좋음

	private int num;
	private String name;

	// 메뉴탭에서 [Source] > [Generate Getter and Setter] > 만든 변수 체크 후 generate

	public int getNum() {
		return num;
	}
	public void setNum(int num) {
		this.num = num;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}



10) static 메소드
클래스가 호출할 수 있는 메소드
- 인스턴스를 생성하지 않고 메소드를 사용하기 위해 만듬
- 자바에서는 인스턴스도 호출 가능
- 결과형 앞에 static 붙이면 됨
- this가 없음
-- Class 안에 만든 인스턴스 변수를 사용할 수 없음
- 지역변수와 static변수만 사용 가능함
	-- 메소드는 원래 '공유'하기 위함.. static 메소드만 이런 거 아님


11) this
- 클래스 내의 static이 없는 메소드의 첫번째 매개변수.
- 인스턴스 자신을 나타내는 포인터
	-- Java에서는 숨겨져 있음
	-- python에서 self
	-- 대부분 객체지향 언어에 있음. c++ 계열.

- static이 없는 메소드는 내부에서 변수를 사용할 때,
	-- 먼저 메소드 안에서 만든 것이 있으면 메소드 안에서 만든 것을 사용
	-- 메소드 안에 없으면 클래스에 선언한 것을 사용하는 때 this. 을 붙여서 사용함

- this를 직접 호출하는 경우
	-- 클래스에 만든 프로퍼티(변수)와 메소드 안에서 만든 변수(지역변수)의 이름이 같을 때
	-- 프로퍼티를 호출하기 위해 this.을 붙임

-- python에서는 메소드 호출방법이 2가지
	객체.메소드(매개변수 나열)		# 다른 언어도 이 방식. 인스턴스 만들어서 씀.
	클래스.메소드(객체,매개변수 나열)	# 파이썬의 특이한 점

- 당연히 static은 this 메소드가 없음.

	// 다음 /**/은 표시되지 않았지만 생략된 부분
	public int getNum( /*SampleClass this*/ ) {
		return num;
	}
	public void setNum(/*SampleClass this, */ int num) {
		this.num = num;
		// this.num 은 바깥의 num, 우측 num은 내부의 int num
	}
	public String getName( /*SampleClass this*/ ) {
		return name;
	}
	public void setName(/*SampleClass this, */ String name) {
		this.name = name;
		// this.name 은 바깥의 name, 우측 name은 내부의 String name
	}
	_______________________________
	publis static void temp(){
		/* stastic은 this가 없음. this가 없어서 바깥의 num이나 name을 사용할 수 없음.*/
	}

- 클래스로 인스턴스를 생성하면 인스턴스는 프로퍼티와 자신의 클래스 참조만 가지고 생성됨
- 메소드는 메소드 영역(static, class 영역)에 만들어져서 동일한 클래스로 만든 모든 인스턴스가 공유함
	-- 그래서 static메소드의 특징이 공유라고 말하는 것은 적절치 않음. 공유는 상위개념인 메소드의 특징임.

- 파이썬은 static 메소드와 class 메소드 2가지가 있음.
-- 둘의 차이는 클래스의 참조를 가지고 있는지, 아닌지의 차이임
	-- cls, @ (어노테이션)
	-- https://hongku.tistory.com/335
	-- @property 사용법 코드 참고

=====
this는 문법
getter/setter은 문법이 아님
=====


12) 재귀 (Recursive Call)
- 메소드가 자기 자신을 다시 리턴하는 경우
-- rn의 r이 재귀의 r
-- 피보나치 수열, 하노이의 탑, quick sort 등이 재귀로 구현하는 예
-- 알파고 1세대(vs. 이세돌)의 알고리즘인 몬테카를로 트리 서치는 재귀로 구현

- 메모리 사용량이 크고, 실행속도는 느려지지만 코드가 간결해짐
	# 코딩테스트 시 주의!
	# 삼전 	# 감독관 배정 문제
	# 금융사는 피보나치 수열 잘 냄

-- 피보나치 수열
	// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233 ...
	_________________________________________________
	// n번째 피보나치 수열의 값을 수해주는 메소드
	// 1) 재귀 사용하지 않음
	public static int fibo1(int n) {
		// 이전 항의 값 저장할 변수
		int n_1=1;
		int n_2=1;
		// 피보나치 수열의 값을 저장할 변수
		int fibo=1;

		// 반복문
		// 피보나치 수열은 계산이 3번쨰부터 적용되기 때문에 초기화 지점도 i=3 
		for(int i=3; i<=n; i++) {
			//이전 2개 항 합쳐서 fibo 생성
			fibo = n_1 + n_2;
			n_2 = n_1;
			n_1 = fibo;
		}
		return fibo;		
	}
	_________________________________________________
	// 2) 재귀 사용함
	public static int fibo2(int n) {
		if(n==1 || n==2) {
			return 1;
		}else {
			// 코드 매우 간결
			// 함수가 종료되기 전에 다른 함수를 호출하면
			// 메모리 사용량이 늘고, 리턴을 계속해야 해서 속도가 느려짐
			// 코드 실행시간 제한이 있다면 재귀 쓰지 말 것
			return fibo2(n-1) + fibo2(n-2);
		}
	}
	_________________________________________________
	// 피보나치 45번째 수 연산 해보면 두 코드의 실행 속도를 체감할 수 있음


-- quick sort 구현해보자 !	# 미션 	# 월요일(24일)에 답 주심~~
-- 하노이의 탑은 고리 쌓기






2. Constructor
인스턴스를 생성할 때 호출하는 특별한 용도의 메소드
- 생성자, 또는 초기화 메소드라고 함
- 언어마다 구현하는 이름이 다름
-- 대다수의 언어는 '클래스이름', 파이썬계열 언어는 'init'

Java의 경우 return 타입이 없고 클래스이름으로 생성함
- Overriding이 가능함
-- Overriding (중복 정의) : 하나의 클래스에 메소드 이름은 같고 매개변수의 개수, 자료형, 순서가 다르게 배치된 메소드

호출
- 클래스나 인스턴스 없이 호출함
	new 생성자이름(매개변수)
	// 생성자이름은 늘 Class이름
	-- 생성자를 호출하면 Heap에 메모리를 할당하고 그 참조를 리턴함
	-- 인스턴스를 만들 때 참조를 저장하기 위해서 변수에 대입함

변수 초기화
- 대부분의 경우 생성자에게는 인스턴스 변수(프로프티)의 초기화 작업을 수행하게 함
-- Class 만들 때 생성자를 만들지 않으면 매개변수가 없는 기본 생성자를 제공함
-- 매개변수가 없는 생성자를 Default Constructor라고 함
	-- 그러니 Default Constructor 쓸 땐 꼭 초기값 부여해야함
-- 생성자를 직접 만들면 기본적으로 제공되는 생성자가 없어짐

DTO (Data Transfer Object)
= VO : Variable Object
- Domain Class
- 하나의 행을 만들기 위한 클래스

-- DTO 대신 Dictionary(Map)을 주로 사용함
-- DataFrame 만들 때 Map이 바로 만들어주기 때문에 DTO 대신 쓰는 경우 많음
- 결과 줄 때 DTO 로 줌.
	-- df. ...
- DTO 클래스를 만들 때는 '매개변수가 없는 생성자'와 '모든 프로퍼티를 매개변수로 갖는 생성자'를 '같이' 만들어서 생성하는 경우가 대부분

	SampleClass.java에서 생성자를 만들지 않았지만
	Main.java에서 new SampleClass();처럼 생성자 new를 써서 부를 수 있음

	// 생성자
	public SampleClass() {
		System.out.println("생성자:");
	}
	___________________________________________________________
	// 매개변수가 있는 생성자?
	// 매개변수가 있는 생성자를 만들면 기본적으로 제공되는 매개변수 없는 생성자가 없어짐
	// 클래스 외부에서는 매개변수가 없는 생성자를 호출할 수 없음
	public SampleClass(int num) {
		this.num=num;
		System.out.println("매개변수가 있는 생성자 :");
	}

	// 따라서 Default Constructor를 추가해줌	// 같이
	// 매개변수가 없는 생성자 - Default Constructor
	// 이렇게 동일한 이름의 메소드가 2개 이상 존재하는 경우를
	// Method Overloading이라 함
	public SampleClass() {
		this.num=num;
		System.out.println("매개변수가 없는 생성자 :");
	}

-# 데이터 분석시 가장 먼저 클래스 용도를 알고 생성자를 확인하자.



1) this()
- 생성자 안에서 다른 생성자 호출할 때 사용
- 생성자 안에서 super() 다음에 위치해야 함
-- 순서규칙 : super()가 있으면 이 구문이 가장 먼저 와야함. 그 다음 this(). 그리고 그 외 코드


2) 생성자를 이용하지 않는 초기화 코드 작성

- stastic 초기화
-- 클래스가 메모리에 로드될 때 1번만 호출되고 가장 먼저 수행됨
-- 게임 타이틀화면, launcher screen, splash image 등 딱 1번만 실행될 내용 구현시 이 방법 씀

	static{
		내용작성
	}

- 인스턴스 초기화
-- static이 없는 상황에서 블록으로 감싸 그 안에 내용을 정의함
-- 인스턴스를 생성할 때마다 수행됨

	{
		내용작성
	}




3) 소멸자
- 인스턴스가 소멸될 때 호출하는 메소드
- 자바는 소멸자가 없음
- public void finalize 메소드를 재정의하면 인스턴스가 소멸될 때 작업을 수행할 수 있음

- Java는 Garbage Collection이 메모리 정리함
-- Java에서 메모리 정리는 인스턴스를 가리키고 있는 변수가 없는 경우 실행함
-- 인스턴스를 가리키는 대상에null을 대입하면 메모리 정리됨

- Python는 Reference Count 방식의 메모리 정리 기법을 제공함
	# 딥카피 위크카피?

- 참조형 데이터를 다른 변수에 대입할 때는 주의해야 함

-- 프로그램은 자신이 만든 자원이 아닌 것은 연결해서 사용함
-- 토큰을 발행하는 방식으로 생각하면 됨
  예) 	서버(토큰30개) <----- 클라이언트 접속(토큰0개)
	서버(토큰29개) <----- 클라이언트 접속(토큰1개)
	-- 서버와 클라이언트가 서로 그만 사용하겠다고 메세지를 주어야 토큰이 반납됨
	-- 로그아웃(토큰반납) 하지 않으면 계속 실행되는 것으로 인식하는 리니지같은 게임
-- 이 경우를 자동으로 소멸자가 정리해줌

- 소멸자는 외부자원(파일, 그래픽 작업, 사운드 작업, 네트워크 자원, DB자원 등)을 '정리'하는 작업을 주로 수행함
	-- 컴퓨터 메모리 사용량 증가해서 버벅이면 재부팅하는 것과 같은 역할

	@Override
	public void finalize() {
		System.out.println("메모리 정리");
	}


	// s에 null이 대입되면 s가 사용하던 공간은 메모리 정리 대상이 됨
	// garbage collection이 호출되면 메모리 정리됨
	s = null;

	// 강제로 garbage collection을 호출
	// 안드로이드, 서버 애플리케이션에서 호출하면 안 됨
	// 안드로이드는 안드로이드만 메모리 관리할 수 있음
	// 서버 애플리케이션에서는 시간이 너무 오래 걸림.
	// 그래서 서버는 정기점검 등으로 한번 껐다 키지 굳이 gc()실행하지 않음
	System.gc();	// 출력: 메모리정리





3. package & import

1) package
- 동일한 목적을 위해 모인 클래스의 집합
- 디렉토리 개념과 유사
- 배포의 단위
	-- 객체지향 프로그래밍에서 하나의 클래스에 여러 개의 함수 넣지 않기로 함
	-- 여러개의 클래스 생김. 그래서 클래스 단위로 배포하지 않음.
- 배포하는 패키지 만들 때는 습관적으로 영어 Document와 함께 배포해야 함


2) import
- Java는 실행될 때 모든 클래스를 메모리에 로드하고 시작
	-- 그래서 중간에 package를 가져오는 경우가 없음
- Java에서 import는 패키지 이름을 줄이거나 생략하기 위해 씀

	import 패키지이름.클래스이름;
	클래스 이름만으로 사용 가능
	//	java.lang.String

	import 패키지이름.*;
	패키지 안의 클래스들은 전부 이름만으로 사용 가능함
	// import lang.String.*;
	// String

	import static 패키지이름.클래스이름;
	클래스 안에 속한 static 멤버나 final 변수를 클래스 이름없이 사용 가능함


- Python이나 R에서는 기본 모듈만 가진 상태로 시작
-- 패키지를 설치하고 import 해야만 사용할 수 있음
-- 기본 모듈 외의 모듈을 사용하려면 메모리로 로드해야 함
	import	:  메모리로 로드
	import ~ as ~	: 패키지 이름을 변경해서 메모리로 로드
	static import	: 기본 모듈에 로드
	-- 파이썬은 중복설치해도 알아서.
	-- R의 경우는 중복설치하면 리셋됨. 처음부터 다시 로드 해야함.


