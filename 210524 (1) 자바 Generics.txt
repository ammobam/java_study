=====
package lesson210524 참고
-- 하나의 자바 소스 파일에 작성된 클래스 중 오직 한 클래스만 public으로 선언할 수 있습니다
-- public으로 선언한 클래스의 이름은 소스파일의 이름과 동일하게 작성해야 합니다.

https://gsgdvxhx.tistory.com/3
=====



**Generics (제네릭스)



- 클래스를 만들 때 (선언 할 때) 자료형을 결정하지 않고
- 실행할 때 (runtime시, 인스턴스 생성 시) 자료형을 결정해서 코드를 실행하는 방식

-- C언어는 객체지향언어가 아님. 인스턴스 없음.
-- C++는 객체지향언어임. 기존의 C를 포괄. 완전한 객체지향이 불가능함.
-- 후에 등장한 java는 완전한 객체지향언어. 지금 시점에서는 의미 없는 말.

- 정적 바인딩을 사용하는 언어와 동적 바인딩을 사용하는 언어로 구분됨.
-- 정적 바인딩 언어
	-- 변수의 자료형을 먼저 결정하고 나중에 이와 동일한 자료형의 데이터만 받아들이는 방식의 언어.
	-- C, C++, Java, C# / Kotlin, Swift
	-- 빠름. 박스에 미리 포장한 경우.
	-- 안정적이고 오래 쓸 애플리케이션 작성에 유리함
		-- Kotlin, Swift : 코딩은 동적 바인딩처럼, 작동은 정적 바인딩처럼 함.

-- 동적 바인딩 언어
	-- 변수를 선언할 때 자료형을 결정하지 않고 데이터를 대입할 때 자료형을 결정하는 방식의 언어
	-- JavaScript, Python, R
	-- 융통성 있음. 미리 만들어놓고 쓰는게 아님. 에러찾기 힘들음.
	-- 변수명 중복 등 오류를 방지하기 위해 주피터 노트북 IDE 씀

-- 정적 바인딩 언어의 문제점 중 하나
	-- 동일한 알고리즘을 사용하는 코드를 데이터의 자료형 때문에 여러번 구현하는 경우가 있음.
	예시) swap함수: 데이터 교체하는 것. 정렬에서 사용.

	// 정수를 swap하는 함수
		swap(int a, int b){
			int temp = a;
			a = b;
			b = temp;
		}

	// 실수를 swap하는 함수
		swapDouble(double a, double b){
			double temp = a;
			a = b;
			b = temp;
		}
			-- C의 경우 swap()과 swapDouble()의 함수명을 swap으로 통일함

-- 이를 해결하기 위해 미지정 자료형 (T)를 이용해서 코드 작성

		class Temp<T> {
		swap(T a, T b){
			T temp = a;
			a = b;
			b = temp;
		}
		}
		Temp obj = new Temp<Integer>();

-- 템플릿 프로그래밍 (Generics, 제네릭스)
	-- '미지정 자료형'을 이용해서 인스턴스를 '생성할 때 자료형'을 결정하는 것
	-- 자료구조나 알고리즘 클래스에 구현되어 있음
	-- 자바에서 클래스어 <이름>이 있으면 이 클래스의 인스턴스를 생성할 때 자료형을 결정하여 생성해야 함
	-- 이 기능이 구현되어 있으면 다른 클래스에 비해 사용 빈도가 높음
	-- 여러 개의 제너릭스를 적용할 수 있음. 이때 ' , '로 구분함
	-- Map(Dictionary)은 2개의 자료형을 미지정 자료형으로 사용함
		-- python에서 dictionary의 자료형 key와 value는 모두 미지정 자료형임.

-- 개발자는 class, 분석가는 instance 만드는 게 중요함
	-- 개발자는 python 깊게 공부할 때 co routine이 나와있는 책 보자. 스레드 등등.
	-- 분석가는 파라미터에 instance를 어떻게 적용해야 서비스가 나올지 염두하기.

