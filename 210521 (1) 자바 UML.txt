NestedClass ppt 참고 



**UML

- Unified Modeling Language
- 분석, 설계를 비주얼화/문서화 하기 위한 그래픽 언어

Hybrid App
스마트폰 : Android & iOS 플랫폼은 사용 언어가 다름
1	Java, Object-C
		public void func(int a)
2	JabaScript 또는 C#으로 2개 플랫폼의 앱을 한번에 만드는 방식 (Hybrid App 개발기술)
3	Kotlin, Swift
		public func(a:int) : Void
		Python과 유사함. 두 언어의 체계 비슷함.
		요즘 등장한 언어는 UML에 맞춤

이클립스에서 다른 언어 작성하는 방법
1-1 	Help > MarketPlace > 언어 검색해서 설치
1-2 	Help > Install New S/W > 해당언어 url 입력해서 설치
2 	New Class 만들 때 ObjectAid ... 선택 (수업중UML이었음)
3	java 작성 파일을 UML 페이지에 drag&drop하면 자동으로 그려짐





**JDK Document
즐겨찾기 링크 해놓자~
http://www.java2s.com/Code

1. 1.8버전
- Document에서는 사용할 수 있는 멤버만 보여줌
-- private멤버는 보이지 않고 사용할 의도도 없어서 안 보여줌
- 클래스를 볼 때 제일 먼저 확인할 것 : Constructor (생성자)

1) 생성자가 없는 클래스
-- (1) 추상클래스 : 인스턴스를 생성할 수 없는 클래스
-- (2) 모든 멤버가 static인 클래스. 클래스로 호출 가능
	-- Method
-- (3) 디자인 패턴(싱글톤 , 빌더팩토리 등)이 적용된 클래스 :
	- 자신의클래스이름 Builder
	- 자신의클래스이름 Factor
	- 자기자신을 리턴하는 static 메소드가 있는지 확인
	-- 예시) java.lang.runtime

2) Field Summary
- static final 이므로 사용자가 생성하거나 값을 변경할 수 없음
-- 클래스 이름으로 접근함
-- 처음부터 필요해서 미리 생성해 둔 것:
	in	표준입력객체, 키보드
	out	표준출력객체, 모니터
	err	에러출력객체, 콘솔에 빨간색으로 출력
-- 클래스 내에서 Option으로 사용하는 경우. 대부분 정수로 되어 있음

- Thread 클래스에는 우선순위 설정을 위해서 상수를 정의함.

				윈도우의 운영체제
	static final int MAX_PRIORITY = 10;
	static final int NORMAL_PRIORITY = 5;
	static final int MIN_PRIORITY = 1;

	Thread.setPriorty(10);	//비추천. 고정됨.
	Thread.setPriorty(Thread.MAX_PRIORITY); // 알아서 적용됨

3) Method
- 인스턴스나 클래스로 호출할 수 있는 메소드
- 설명이 같이 있는 메소드는 클래스에서 새로 만들었거나 상속받은 클래스의 메소드를 재정의한 것
- 설명 없이 이름만 있는 메소도는 상속 받은 그대로를 사용함

자바에서 Deprecated는 

2. Sample Code

3. 알고리즘 사이트





** Exception Handling (예외 처리)
1. 오류의 종류
1) 물리적 오류
- 프로그래밍 언어의 문법에 맞지 않게 작성한 것
- 실행되지 않음
- 대부분 IDE는 물리적 오류의 경우 표시해줌

2) 논리적 오류
- 문법 오류는 없지만 알고리즘 오류로 인해 잘못된 결과가 만들어짐
- 디버깅을 이용해 문제 해결
-- 디버깅 : 코드의 부분을 실행하여 메모리 값을 확인하는 작업

3) 예외 (Exception)
- 문법 오류는 없지만 특수한 상황이 발생하면 프로그램이 중단되는 현상
- 디버깅을 통해 해결 (이렇게 해결되는 경우는 코드를 잘못 짠 것임)
- 어쩔 수 없는 경우 예외처리 수행

4) 단언 (Assertion)
- 문법 오류가 아닌데 특정 조건을 만족하지 않으면 
- 강제로 예외를 발생시켜서 프로그램을 중단시키는 것
-- 운영체제를 업그레이드 하면 어플이 실행되지 않는 경우
-- 은행 어플 같은 경우 탈옥 폰에서 돌아가지 않는 것


2. Eclips에서의 Debugging
- 코드 왼쪽의 빈 영역 (Gutter)에서 마우스 우클릭 > Toggle BreakPoint 생성
- 디버깅 할 때 Run 대신 Debug 실행
- 메모리 값과 스레드를 모두 확인 가능함

-- 디버깅? 내 코드가 어떤 식으로 돌아가는지 알아두자
-- 젠킨스, 지라 등등 코드 리뷰하기 좋은 툴 구경이나 해보자


3. Exception 분류
- java는 오류를 Throwalble 인터페이스로 분류. 에러와 익셉션이 있음
1) Error : 심각한 예외
2) Exception :  Error 보다는 덜 심각한 예외
-- Runtime Exception : 예외처리 하지 않아도 되는 예외
-- Runtime Exception이 아닌 것 : java에서는 반드시 예외처리 해야하는 예외
- 예외처리를 잘 하면 시간을 아낄 수 있다


4. Throwable의 멤버
- String getMessage() : 예외 메세지를 리턴
	- 언어마다 이름이 달라짐
	- localizedMessage, description
- voidprintStackTrace() : 예외 발생 지점을 역추적
	- 콘솔에 빨간색 표시


5. 예외처리의 목적
1) 예외가 발생했을 때 이를 로깅하기 위함
	-- 지라 연동
2) 예외가 발생하더라도 프로그램을 계속 실행시키기 위함


===========
예외는 언제 발생할까?

* 컴파일 과정

소스코드 작성
컴파일	문법 체크, 정확히는 자료형 체크
	-- 물리적오류 발생 포인트
class 생성 (java의 경우)
build	클래스간의 관계설정, entry point 설정
load	메모리 할당
run	실행
	-- 예외 발생
===========

6. 예외 처리 방법
1) 예외를 발생한 곳에서 처리 (try)
	try {
		예외 발생할만한 코드
	}catch(Exception클래스 변수){
		예외발생시 수행한 내용
	}finally{
		예외발생여부와 무관하게 수행할 내용
	}
-- catch는 0번 이상 여러개 작성 가능
-- 클래스 이름이 서로 달라야 함
-- finally는 생략하거나 한번만 나와야 함
- java에서는 try가 나오면 catch 또는 finally 둘 중 하나는 반드시 작성
-- 다른 언어는 try구문에서 catch가 필수지만 java는 finally만 나와도 됨

2) 예외를 자신이 호출한 곳으로 넘겨서 처리 (throw)
- throw 예외객체를 메소드 선언 마지막에 추가하면 됨
- 이 예외객체를 받은 곳에서는 반드시 예외처리 코드를 작성해야 함


6. catch 작성

1) catch를 여러개 작성
- 여러가지 예외를 구체적으로 분류하여 처리하기 위함
- 각 catch 구문의 예외 클래스 이름은 서로 달라야 함
- 예외 처리 클래스의 최상위 클래스는 Throwable -> Exception
- Throwable 또는 Exception을 먼저 처리하고 다른 예외를 나중에 처리하면 에러 발생함
-- catch는 if문처럼 작동해서 앞블럭에 일치하는 예외를 만나면 뒷블록은 실행되지 않음
-- 상위 클래스를 앞에 작성하면 뒤의 catch는 unreachable code가 됨
	// Unreachable catch block for ArrayIndexOutOfBoundsException.
	// It is already handled by the catch block for Exception


2) 모든 예외를 묶어서 처리
- 예외처리 클래스를 Throwable 또는 Exception 설정하면 됨


7. 예외를 던지는 메소드 처리
- Thread.sleep 이란 메소드는 현재 메소드를 매개변수로 대입된 시간만큼 delay 시켜줌
-- https://docs.oracle.com/javase/8/docs/api/에서 검색
	public static void sleep(long millis)
		throws InterruptedException

- 이 메소드를 호출해서 사용하는 쪽에서 InterruptedException을 해달라는 뜻
-- 'sleep 메소드는 InterruptedException 예외를 던진다'


8. 강제로 예외 발생
	throw 예외객체;


9. Custom 예외 클래스
- 개발자가 직접 만든 예외 클래스
- Exception 클래스를 상속 받아서 생성
- 생성자에 메세지를 받아서 메세지를 출력하는 형태로 작성
- 예외가 발생했을 때 사용자의 메시지를 출력하거나 로깅하기 위한 목적으로 사용함


10. try ~ with ~ resource
	try(인스턴스 생성){
		예외 발생할만한 코드
	}catch(예외클래스 변수명){
		예외처리 문구
	}

- try를 만들고 finally를 만드는 이유 : 반드시 close 해야하는 자원을 try에서 사용하기 때문
-- 파일, 네트워크, 데이터베이스, 멀티미디어 재생, 그래픽 출력 등

	자원변수;
	try{
		변수 = 자원생성코드;
	}catch{
	}finally{
		자원해제
	}
	-- 변수 범위 때문에 번거로움

- try() 안에서 생성한 자원은 블럭이 끝나면 자동으로 close해줌

try(
~~~~~~~~~~~~~~~~~~~~~~~~~~~ 코드 찾아봐 ??????





** java.lang 패키지

- 자바의 기본 패키지
- import 하지 않아도 import 된 것으로 간주함
========
실습 파일
Student.java
StudentMain.java
========


1. java.lang.Object
- 자바의 최상위 클래스
- 자바의 클래스는 이 클래스로부터 상속 받음
- 이 클래스는 직접 인스턴스 생성하는 경우는 거의 없음

- 함수의 매개변수가 Object면 어떤 종류의 데이터든지 입력 가능함
- return type이 Object면 반드시 강제 형변환을 통해서 원래 클래스 타입으로 변환해서 사용해야함

- 주요 메소드

- 다음 4개는 Overriding(재정의)해서 사용함
Object clone()
	-- deep copy를 위한 메소드로 클래스에서 재정의 해서 사용함
boolean equals()
	-- 2개의 인스턴스 내용이 같은지 비교하는 함수
	-- 재정의해서 사용함
	-- 통상적으로 hashCode() 메소드와 같이 재정의함
int hashCode()
	-- 해시코드를 리턴하는 메소드
	-- 해시코드: 인스턴스를 다른 인스턴스와 구별하기 위한 아이디
	-- equals() 재정의할 때 같이 재정의 할 것을 권장함
String toString()
	-- 인스턴스를 대표하는 문자열을 반환하는 메소드
	-- 출력하는 메소드에 인스턴스 이름을 대입하면 이 메소드가 호출되어 문자열을 출역함

notify(), notifyAll(), wait()
	-- 멀티 스레드와 관련된 메소드
	-- 생산자와 소비자 이슈에서 사용함
	-- 재정의x


2. 인스턴스의 등가성
1) instance of 연산자
- 어떤 인스턴스의 자료형이 형변환 가능한지 확인할 수 있는 연산자
- 좌변의 인스턴스가 우변의 클래스로 형변환 가능 여부를 boolean값으로 리턴함

2) 등가성
- 가리키는 위치가 같은지 판정
- 실제 인스턴스 안의 데이터가 같은지 확인 가능함

'=='
- 위치가 동일한지 판단할 때 사용하는 연산자
-- 실제 저장한 내용은 같은데 별도의 인스턴트인 경우 false 리턴함

equals
- 내용이 동일한지 판단하기 위한 메소드
-- 재정의해서 사용할 수 있음
-- hashCode 메소드도 함께 재정의하는 것을 권장함

해시코드
- 실제 해시코드를 출력하고자 할 때
- hashCode 메소드가 아닌 System.identityHashCode를 호출함
	System.identityHashCode(해시코드를 알고싶은 데이터)


3. DTO (Data Transfer Object, VO, Domain Class)
- 여러개의 속성을 모아서 하나의 데이터를 표현하기 위한 클래스
- 테이블의 행을 표현하기 위한 클래스
-- 이 클래스 대신 Map을 사용하기도 함

========
클래스
인스턴스
스키마 (DB)
DTO 
========


4. 참조형 데이터의 복사
- 여러개의 데이터를 저장하고 있는 데이터를 =로 다른 변수에 대입하면 참조가 복사됨
- 2개의 변수는 동일한 데이터를 가리키게 됨. 따라서 하나의 변화가 다른 하나에 영향을 줌.
-- 이를 종속이라 함
-- 프로그램에서 금기시 됨

- Java에서 종속 문제를 해결하기 위해 copy 메소드를 재정의하여 deep copy 하도록 함
-- 되도록 deep copy 권장
-- 데이터분석 분야에서는 특별한 경우가 아니면 copy 사용
-- python은 기본적으로 deep copy가 없음
-- pandas, numpy는 deep copy 구현함

- weak copy : 내부데이터 중 참조형은 '참조'를 복사함
- deep copy : 내부데이터 중 참조형은 '내부데이터'를 재귀적으로 복사함

- 데이터 분석 분야
-- raw 데이터를 변경하지 않고 데이터를 복제하여 작업을 수행하는 경우가 많음

- R은 모든 작업이 기본적으로 deep copy 수행
- 파이썬의 데이터분석 라이브러리는 deep copy 수행
- 파일을 이용하는 프로그램은 파일을 열면 deep copy 수행
-- 저장하면 수정한 내용을 원본 파일에 반영됨
- 데이터베이스에 접속하면 데이터베이스의 데이터를 deep copy해서 우리에게 줌
-- 이 데이터를 commit 요청해야만 원본 데이터가 변경됨
-- roll back을 수행하면 원본 데이터는 변화가 없음
	-- roll back: 게임에서 템 줍고 저장 안하고 끌 경우 템 줍기 전으로 돌아가 있는 것


5. Wrapper Class
- 기존 데이터를 감싸서 가공하는 작업을 Wrapping이라고 함
- 기본 자료형 데이터를 다른 벡터데이터처럼 사용할 수 있도록 하는 클래스
-- 기본 자료형: boolean, byte, short, char, int, long, floa, double
- Boolean, Byte, Short, Character, Integer, Long, Float, Double이 있음

-- Character, Integer은 특이함

1) Integer 상호간의 변환

- 기본 자료형을 Wrapper 클래스 타입으로 변환할 때
	new WrapperClass이름 (데이터)

- Wrapper 클래스 데이터를 기본 자료형으로 변환할 때
	인스턴스.자료형Value()

예시) 	Integer i = new Integer(10);
	int d = i.intValue();

-- 위 방법은 잘 사용하지 않음.
- 1.5 버전 이후 Auto Boxing/Auto Unboxing 개념 도입
- java가 자동으로 Boxing/Unboxing 해줌
	Integer i = 10; 	// Auto Boxing
	int d = i;		// Auto Unboxing 

2) 문자열로 만들어진 데이터와 Wrapper 클래스의 데이터 변환
- 문자열로 만들어진 데이터를  Wrapper 클래스의 데이터로 변환
-- 생성자 이용
	String str = "10";
	Integer i = new Integer(str);
-- parse 메소드 이용
	Integer i = Integer.parseInt(str);

- 숫자 데이터를 문자열로 변환
-- 기록을 하기 위함
-- GUI 시스템은 숫자를 출력하지 못함. 메모장 등.
	숫자객체.toString()
	숫자데이터 + " "


6. BigInteger & BigDemical

1) BigInteger
- 큰 정수를 다루기 위한 클래스
-- int는 절대값으로 약21억까지만 사용 가능
-- 내부적으로는 int 배열로 정수 관리

- 생성할 때 생성자에 문자열로 정수 대입해서 생성
- 정수로 변경할 때 intValue 호출

2) BigDecimal
- 큰 수를 다루기 위한 클래스
-- Float, Double이 2진수 표현법을 사용하기 때문에 정밀한 수를 정확하게 표현하는 것이 어려움
-- 정밀한 수를 표현하기 위해서 "숫자를 문자열로 관리"하는 클래스
-- 실수 연산을 정확하게 수행하기 위한 클래스

- 전자정부 프레임워크에서 사용함
-- MyBatis 이용해서 Oracle 사용하고
-- DTO 대신 Map을 이용해서 DB 연동하게 되면
-- Oracle의 Number 타입은 BigDecimal과 매핑됨
-- Oracle이 java보다 수를 정밀하게 다룸


7. System 클래스
- 실행 환경과 관련된 클래스
- in, out, err 프로퍼티를 이용해서 표준 입출력 수행 가능
-- System.in : 표준 입력 객체 (키보드)
-- System.out : 표준 출력 객체 (모니터)
-- System.err : 표준 에러 객체. 에러 발생시 출력
-- epoch time : 현재 시간을 리턴해주는 currentTimeMillis()와 nanoTime() 메소드가 있음
	-- 1970년 1월 1일 자정을 기준으로 흐른 시간
-- 환경 설정과 관련된 getProperty, getenv 같은 메소드 소유


8. Class 클래스
- Class에 대한 정보를 가지고 있는 클래스
- Class에 대한 정보 : Reflection 기능
- 이 클래스는 IDE, Debugger, Build Tool 같은 것을 만들 때 사용함
-- 다른 클래스의 인스턴스를 이용해서 Class클래스의 인스턴스 생성


9. Math 클래스
- 수학과 관련된 메소드를 가진 클래스
-- Java의 MathClass를 JavaScript가 그대로 들고감
- 시스템(운영체제)에 따라 다르게 동작함
-- 모든 운영체제에서 동일한 결과를 얻고자 하는 경우 StrictMath 클래스를 이용함
-- 대신 StrictMath 클래스의 연산속도는 느림


10. Runtime 클래스
- 프로세스 실행과 관련된 클래스
- exex 메소드를 이용해서 프로세스를 실행함
-- 자신의 static 메소드를 이용해서 인스턴스 생성





** 문자열 클래스

1. 종류
1) String
- 변경할 수 없는 문자열을 저장
- '+' 연산을 이용해서 문자열 결합
-- 기본적으로 변경할 수 없는 문자열이기 때문에 복사해서 문자열 더하기 수행함
-- 과거에는 문자열 더하기 연산을 많이 하면 메모리 낭비가 심해졌는데
	------------------
과거	" Hello + World "
	Hello 저장
	Hello 복사하여 + World
	Hello는 쓰지도 않는데 Hello+World가 있는 이상 지울 수도 없음
	-------------------
-- 1.7 버전 이상에서는 최적화를 수행하기 때문에 상관 없음


2) StringBuffer
- 멀티 스레드에 안전함
-- 사용할 때 다른 스레드가 사용 중인지 확인하고 사용함
-- StringBuilder는 멀티 스레드에 안전하지 않음. 확인하지 않고 사용하기 때문. 속도는 더 빠름.

- 변경될 수 있는 문자열을 저장함
-- 문자열 결합할 때 append 메소드를 이용하는데 복사를 하지 않고 결합을 함

=====
람다, 스트림
과거에는 callby...
참조
=====


2. String 클래스

1) 문자열 다룰 때 알아둘 내용
- 영문인 경우 대소문자 구별 여부
	-- ID나 검색창에서 대소문자 구분 안 하고 같은 결과 보여줌
- 좌우 공백 문제
- 특정한 패턴 찾기
	-- 정규식과 indexOf나 find 같은 메소드 활용
	-- 의료데이터 분석에서 염기서열 분석
	-- 세포의 배열순서에서 특정한 패턴 찾아서 진단

- 특정 패턴을 이용해서 분할함
	-- split

- 위치를 가지고 분할하는 것
	-- substring : n번째까지는 빼고 분할

- 한글이 포함된 경우 인코딩
	-- 의료 쪽은 과거에 ms 기반으로 운영되어 ms949로 인코딩 된 파일이 많음.

========
- java로 코딩테스트 연습 시
-- charAt, length 메소드만을 이용해서 모든 문제 해결하는 연습하기

- 코딩 테스트 할 때 C&C++, java, python 등을 제공함
-- C&C++은 String 클래스가 없고 문자열을 문자 배열로 나타냄
-- 글자 개수가 각 문자를 가져오는 것은 가능한데 나머지는 직접 구현해야 함
========


2) 문자열 생성 방법
-(1) 문자열 리터럴을 이용해서 생성
	String str = "Hello Java";

-(2) 문자열을 대입받는 생성자를 이용하는 것
	String str = new String("Hello Java");

-(3) 바이트 배열을 받아서 생성
-- 바이트 배열과 인코딩을 갖고 생성함
-- 네트워크에서 받은 문자열이나 파일에서 읽은 문자열의 경우 많이 사용함
	String str = String (byte[] bytes, String charsetName)


3) 주요 메소드

- length() : 문자열의 길이
- char charAt(int index) : index번째 문자 리턴
	-- 알고리즘 공부
	-- length(), charAt로 String Class 구현
- byte[] getBytes(String charsetName) : 인코딩을 적용한 바이트 배열을 리턴

예시	__________
	10, 20
	30, 50
	50, 80
	-, 0	// 예외처리해야함
	__________	// - : 영업일아님 , 0 : 매출없음

# 팁======
뭘만들때 책보단 실제 제품 보고 만들자.
게시판 검색기능 구현할 때 대소문자 무시, 좌우공백 제거 정도는 해줘야함
=========



4) Surrogate 문제
- Java는 utf-16을 이용함
-- 특수문자는 ♧ 2글자로 취급함.
-- length가 예상한 것과 다르게 출력되는 경우 (Surrogate 문제 발생)
-- codePointCount 메소드를 이용함


3. StringBuilder 클래스 (append)
- 변할 수 있는 문자열 저장에 사용함
- append라는 메소드를 이용해서 문자열을 추가함
- 문자열을 여러번 연결한다면 StringBuilder가 String보다 메모리 효율이 좋음
-- 최근 자바가 어느정도 최적화 했기 때문에 큰 차이는 없음


4. 자주 사용되는 인터페이스
- 인터페이스 (= Protocol) : 반드시 구현되어 있다는 약속

1) Cloneable : 복제를 위한 copy 메소드를 가진 인터페이스

2) Comparabla : 크기 비교가 가능한 compareTo라는 메소드를 가진 인터페이스
- '크다': 기준점의 데이터가 큰 경우. 양수로 표현 (+1)
- '같다': 2개의 데이터가 일치하는 경우. (0)
- '작다': 기준점의 데이터가 작은 경우. 음수로 표현 (-1)

3) Iterable : 빠른 열거를 사용할 수 있음 - for(?:?)

4) Runnable : 스레드 인터페이스

5) Serializable : 파일 저장 가능, 객체 단위로 전송이 가능한 인터페이스
	-- python의 pickle 모듈

6) Listener : 이벤트 처리를 위한 메소드를 가진 인터페이스





** 연습문제
1. 염기서열
String str = "GCATGCCGATGCGTATCGGTATGCAGTATTGAAGCGCCGATCGGCTA";
- 위 문자열에서 GCCG가 나온 위치 전부 출력
- 단 GCCGCCG처럼 GCCG끼리 겹치는 경우는 제외
- Java로 한다면 String 클래스의 length(), chatAt 메소드만 이용

- 남들과 다른 형태로 코드를 구현했을 때
-- 실제 실행 시간 확인
-- 반복문의 개수 (적은게좋음)
-- 반복문 안에서 돌아가는 횟수 가지고 비교함


2. Quick Sort
- 빠른 정렬 알고리즘 중 하나
- 데이터베이스에서 가져온 데이터를 정렬하여 사용함
-- 대부분의 경우 정렬함수를 이용해서 정렬 가능함
-- 정렬함수는 특정 알고리즘을 이용함
-- 만약 해당 알고리즘이 데이터와 안 맞는 방법인 경우 직접 데이터를 정렬해야 함

_______________________________________________
40 30 50 70 10 60 20

1번째 회전
-- 가장 왼쪽의 데이터를 기준으로 설정 (40, 기준데이터)
-- 왼쪽에서 비교의 출발점을 설정함 (30, 왼쪽 비교지점)
-- 오른쪽에서 비교의 출발점은 맨 끝 (20, 오른쪽 비교지점)
-- 기준데이터보다 왼쪽 비교지점의 데이터를 비교하여 기준데이터보다 더 큰 데이터를 만날 때까지 비교
	40 30 50 70 10 60 20
-- 기준데이터와 오른쪽 비교지점 데이터를 비교해서 기준데이터보다 작은 데이터를 만날 때까지 왼쪽으로 오면서 비교
	-- 2개의 데이터를 찾으면 2개 swap (자리교체)
	40 30 20 10 70 60 50
-- 오른쪽의 비교지점보다 왼쪽의 비교지점이 클 때까지 반복함
-- 기준데이터를 가운데 데이터(교차지점의 데이터)와 swap
	10 30 20 40 70 60 50

2번째 회전
-- 가운데 기준(40)으로 왼쪽배열과 오른쪽배열을 동일한 방법으로 진행
-- 10 30 20 과 70 60 50 을 가지고 동일한 방법으로 정렬 수행
-- 이작업을 반복 수행하여 좌우 데이터가 1개가 될 때까지 진행
_______________________________________________
자료구조 > 알고리즘 > 퀵소트 그림 확인
_______________________________________________


3. 이분검색
- 정렬된 데이터에서 데이터를 검색하는 알고리즘
- 찾고자하는 데이터와 가운데를 비교함
- 찾고자하는 데이터와 가운데 데이터가 같으면 찾은 것
- 같지 않고 작으면 왼쪽에서, 크면 오른쪽에서 찾음
_______________________________________________
10 20 30 40 50 60 70

검색데이터 : 30
왼쪽 끝지점 left: 0
오른쪽 끝지점 right: 6
middle: (0+6)/2 = 3

3번째 데이터(40)와 비교해서 크기 비교
30 < 40
작은 경우 right를 middle - 1로 설정해서 다시 middle 계산후 비교
큰 경우 left를 middle + 1로 설정해서 다시 middle 계산후 비교
이때 right값이 left값보다 작아지면 검색데이터는 없는 것
_______________________________________________
30		70		55 - right<left - 데이터는 존재하지 않음
left: 2		left: 4->5->6	left: 5
right: 2		right: ->-> 6	right: 4
m: 2		m:  ->-> 6	m: 4
_______________________________________________

|ll|ll|ll|||l|
제품 만드는 개발자는
스레드, 코.. .. 꼭 해보자.
Oracle 깔아두자
	-- Window로 안 깜. Linux나 Unix로.
|ll|ll|ll|||l|